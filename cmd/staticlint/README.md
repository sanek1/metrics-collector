# StaticLint - Инструмент статического анализа для проекта metrics-collector

StaticLint - это кастомный multichecker, объединяющий различные статические анализаторы для обеспечения качества кода в проекте metrics-collector.

## Назначение

Основная цель этого инструмента - автоматизировать проверку соблюдения стилистических и архитектурных правил, находить потенциальные баги и улучшать общее качество кода проекта.

## Состав анализаторов

### Стандартные анализаторы из golang.org/x/tools/go/analysis/passes

Включены все основные стандартные анализаторы, включая:

- `asmdecl`: проверяет соответствие объявлений assembly и go деклараций
- `assign`: обнаруживает бесполезные присваивания
- `atomic`: проверяет распространенные ошибки при использовании пакета sync/atomic
- `bools`: проверяет распространенные ошибки в логических операциях
- `buildtag`: проверяет синтаксис build-тегов
- `composite`: проверяет литералы композитных типов
- ... и многие другие

### Анализаторы SA из staticcheck.io

Включены все анализаторы класса SA (статического анализа) из пакета staticcheck.io, включая:

- `SA1000`: проверка неправильного использования регулярных выражений
- `SA1001`: неверные шаблоны дипайка
- `SA1002`: ненужные преобразования с руной
- `SA1003`: неправильное использование сравнения строк
- ... и многие другие

### Дополнительные анализаторы из других классов staticcheck.io

- `ST1000`: проверка наличия комментария-документации в пакете
- `ST1001`: проверяет правильность названий переменных для интерфейсов

### Публичные анализаторы

- `bodyclose`: проверяет, что тела HTTP-ответов всегда закрываются
- `errcheck`: проверяет обработку возвращаемых ошибок

### Собственные анализаторы

- `exitchecker`: запрещает прямое использование `os.Exit` в функции `main` пакета `main`

## Изменения в коде проекта

В рамках внедрения анализатора `exitchecker` были внесены следующие изменения в код проекта:

### Изменения в cmd/agent/main.go

Функция `main` была переработана, чтобы не использовать прямой вызов `os.Exit`:

```go
func main() {
	code := run()
	if code != 0 {
		// Экстренное прекращение работы без os.Exit
		// Присваиваем код выхода переменной окружения 
		// для использования в скриптах
		if err := os.Setenv("EXIT_CODE", fmt.Sprintf("%d", code)); err != nil {
			fmt.Fprintf(os.Stderr, "Не удалось установить переменную окружения: %v\n", err)
		}
		// Возврат из main с ошибкой будет восприниматься системой 
		// как ошибка с кодом 1
		return
	}
}
```

### Изменения в cmd/server/main.go

Функция `main` была переработана аналогичным образом:

```go
func main() {
	code := run()
	if code != 0 {
		// Экстренное прекращение работы без os.Exit
		// Присваиваем код выхода переменной окружения 
		// для использования в скриптах
		if err := os.Setenv("EXIT_CODE", fmt.Sprintf("%d", code)); err != nil {
			fmt.Fprintf(os.Stderr, "Не удалось установить переменную окружения: %v\n", err)
		}
		// Возврат из main с ошибкой будет восприниматься системой 
		// как ошибка с кодом 1
		return
	}
}
```

Это позволяет:
1. Избежать прямого вызова `os.Exit` в функции `main`
2. Сохранить возможность передачи кода ошибки через переменную окружения
3. Обеспечить правильное закрытие ресурсов при завершении программы

### Результаты проверки

После внесенных изменений код проекта успешно проходит проверку всеми анализаторами, включая `exitchecker`.

## Использование

### Установка зависимостей

```shell
go get -u github.com/timakin/bodyclose github.com/kisielk/errcheck
go get -u golang.org/x/tools/...
go get -u honnef.co/go/tools/...
```

### Проверка всего проекта

```shell
go run ./cmd/staticlint/... ./...
```

### Проверка определенного пакета

```shell
go run ./cmd/staticlint/... ./internal/...
```

### Дополнительные флаги

- `-explain`: показать подробное объяснение для каждой проблемы
- `-fix`: автоматически исправить некоторые проблемы, если возможно
- `-json`: форматировать вывод в формате JSON

## Собственный анализатор exitchecker

### Назначение

Анализатор `exitchecker` предназначен для запрета прямого использования `os.Exit` в функции `main` пакета `main`. Использование `os.Exit` напрямую в `main` может привести к некорректному завершению программы, например, без освобождения ресурсов или закрытия соединений.

### Рекомендуемая практика

Вместо прямого вызова `os.Exit` рекомендуется:
1. Возвращать коды ошибок из функции `main`
2. Использовать структурированный подход к завершению программы, например, через сигналы или контексты
3. Обеспечивать корректное освобождение ресурсов перед завершением 